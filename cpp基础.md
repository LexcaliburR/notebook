# 一. 编译内存相关
*1.C++程序编译过程*  
编译预处理 -> 编译、优化 -> 汇编(翻译成机器指令) -> 连接
编译预处理：#define/#ifdef...编译等等操作，会生成.ii文件  
编译、优化：解析if/while等逻辑语句，转换成汇编代码，生成.s文件  
汇编：通过汇编器将汇编代码转换成机器指令，生成.o文件  
连接：将相关的目标文件彼此连接。

*2.动态连接和静态连接及他们的优缺点*  



*3.cpp内存管理（5星）*
一个由c/c++编译的程序占用的内存分为栈、堆、全局区、文字常量区、程序代码区这五个区域  
栈：  
由编译器自动分配释放；用于存放函数的参数值，函数的局部变量，返回地等，如函数括号"{}"中定义的变量  
堆：  
由程序员分配释放，使用malloc分配，如果程序执行结束还没有释放，操作系统会自动回收。其大小不固定，可动态扩张或所见。当进程调用malloc等函数分配内存时，新分配的内存就被动态的添加到堆上；当利用free等函数释放内存时，被释放的内存从堆中被剔除    
全局区/静态存储区(.bss段和.data段)：  
存放全局变量和静态变量，程序运行结束后由操作系统自动释放；初始化的放在一个区域，未初始化的放在另外一个区域  
常量存储区：  
存放常量，不允许修改，程序运行结束自动释放  
代码区：  
之用来存放程序执行代码的一块内存区域，不允许修改，为二进制文件。

*4.堆和栈的区别（5星）*


*5.什么是内存泄漏*


*6.智能指针有那几种？智能指针的实现原理（5星）*  
share_ptr, unique_ptr, weak_ptr

*7.使用智能指针会出现什么问题？怎么解决？（5星）*  
相互引用，两个类中分别定义了指向另外一个类的share_ptr，由于在程序结束后，两个指针分别指向另外一个对象，导致内存无法释放，产生内存泄漏。
使用weak_ptr;

---
# 二. 语言对比
*1.c++ 11新特性？*


# 三. 面向对象
*1. 什么是面向对象？面向对象的三大特性？*  
对象指具体的某一个事物，这些事物的抽象化叫做类，具有对应的成员变量和成员方法  
封装：把成员函数和成员变量包起来，只暴露接口，降低耦合性  
继承：子类继承父类，具有父类的非private的方法和属性，并且子类可以对父类的方法进行重写  
多态：不同派生类的对象，对同一消息会有不同的反映，例如有一个基类指针，在指向不同的派生类的对象时，调用的是每个派生类重写的虚函数    

拓展：多态是怎么实现的？

*2.重写, 重载, 隐藏的区别?*  
重载：多个同名函数，根据输入参数的不同进行区别  
重写：派生类重写基类的虚函数  
隐藏：只要派生类和基类具有同名函数，那么基类的同名函数就会被屏蔽    

*3.什么是多态？多态如何实现*  
多态指不同派生类的对象，对于同一信号会有不同的反映；具体来说，假如有一个基类指针，在指向不同的派生类对象时，会根据类调用对应的函数，指向基类对象时，就调用基类的方法，指向派生类对象时，就调用派生类对象的方法。  
实现过程：  
通过虚函数实现的，虚函数的地址保存在虚函数表中，虚函数表的地址保存在含有虚函数的类的实例对象的内存空间中。


*4.虚函数表*


*5.动态绑定是什么*


---
# 四. 关键字库函数

*1.static的作用*
修饰变量：变量只会初始化一次，并且改变了其生命周期，变量在程序运行结束之前一直存在  
修饰全局变量和函数：被修饰的变量和函数只能在定义的文件内使用  
在类中修饰变量和函数：被修饰的变量和函数可以被类调用使用，同时被所有实例化的对象共享；修饰的成员变量要在类外面初始化  

*2.static 在类使用中的注意事项（定义，初始化和使用）*  
静态成员变量：  
在类里声明，类外定义和初始化，且在定义和初始化时不用private,public,protected  
相当于类域里的全局变量，被类的所有对象所共享，也被派生类的对象共享  
可以作为成员函数的参数，而普通成员变量不可以  
静态成员变量的数据类型可以是包含该变量的类本身，而普通成员变量只能是指针或引用  
静态成员函数：  
静态成员变量不能调用非静态的成员变量和非静态的成员函数，因为静态成员函数没有this指针。静态成员函数作为类作用域的全局函数  
静态成员函数不能声明成虚函数，const函数和olatile函数

*3.为什么static成员函数不能是const函数*  
因为const成员函数在调用时相当于传入一个const this 指针，而静态成员函数没有this指针，所以静态成员函数不能时const函数

*4.为什么static成员函数不能是虚函数*  
*5.为什么static成员函数不能是volatile函数*  
*6.this指针*  
this是一个const指针，指向当前对象，可以通过他访问当前对象的所有成员  
this实际上是成员函数的一个形参，在调用成员函数时，将对象的的地址作为实参传递给this。不过this的形参是被隐藏的，不会出现在代码中，在编译阶段由编译器默默的将它添加到参数列表中  

*7.const在类中的使用*  
可以用来修饰成员变量，成员函数以及对象  
const成员变量：  
只需要在声明时加上const关键字就行；只能通过参数初始化表进行初始化。  
const成员函数：  
const成员函数通过在函数头部加上const实现，注意在声明和定义时都需要加，如 char *getname() const和 char *getname()是两种函数原型    
const成员函数可以使用所有的成员变量，但是不能对成员变脸进行修改，最主要的作用还是为了保护数据，使语义变得更加明显  
const对象：
const也可以修饰对象，但是const对象只能调用类的const成员，因为非const的成员可能会修改对象的数据    

*8.什么是参数初始化表*
在定义构造函数时，在函数首部后添加冒号，然后紧跟成员变量，成员变量后跟小括号，括号内就是要赋值给该变量的值  

*9.new和malloc的区别, delete和free的区别*  
new在申请空间时，不需要指定分配空间的大小，编译器会根据类型自动计算；malloc需要指定。  
new的返回类型时对象的指针类型，无需强制转换，malloc返回的void*类型，需要进行强制转换  
对于自定义的类型，new首先调用operator new()申请空间(底层通过malloc实现)，然后通过构造函数进行初始化;delete首先调用对象的西沟函数，然后调用operator delete()释放空间(底层通过free)实现。

---
# 五. 类相关  
*1.类成员变量怎么初始化？*  
通过在构造函数中对成员变量一一赋值  
通过参数初始化表  

*2.什么是虚函数？什么是纯虚函数?*  
虚函数只被virtual修饰的成员函数，纯虚函数指在声明虚函数时加上=0  
纯虚函数的特征：
含有纯虚函数的类称为抽象类，不能进行实例化，类中只有接口，没有具体的实现方法;  
继承纯虚函数的派生类，如果没有完全实现基类纯虚函数，依然是抽象类，不能实例化对象  

抽象类对象不能作为函数的参数，不能创建对象，不能作为函数的返回值  
可以声明抽象类指针和引用  
子类必须继承父类的纯虚函数，并全部实现后，才能创建子类的对象  

*3.虚函数和纯虚函数的区别？*  
使用方式不同:虚函数可以直接使用，纯虚函数必须在派生类中实现才可以使用(具体怎么理解)  
定义形式不同:虚函数在定义时在普通函数的基础上加上virtual关键字，纯虚函数除了加上virtual关键字还需要加上=0  
虚函数必须要实现,否则编译器会报错  
对于实现纯虚函数的派生类，该纯虚函数在派生类中被称为虚函数，虚函数和纯虚函数都可以在派生类中重写  
析构函数最好定义为虚函数，特别是对于含有继承关系的类；
析构函数也可以定义为纯虚函数，此时，其所在的类为抽象基类，不能创建实例化对象。

*4.虚函数的实现机制*  

*5.单继承和多继承的虚函数表结构*  

*6.什么是类的默认构造函数*  

*7.构造函数、析构函数是否需要定义成虚函数，为什么？*

*8.多重继承是会出现什么状况？如何解决？*

*9.空类占多少个字节？c++编译器会给一个空类自动生成哪些函数？*  

*10.什么是拷贝构造函数？*  

*11.cpp对象的初始化顺序？*  

*12.为什么用成员初始化列表会快一些？*  

*13.实例化一个对象需要那几个阶段？*  

*14.深拷贝和浅拷贝的区别（5星）*  
如果一个类拥有资源，该类的对象进行复制时，如果资源重新分配，就是深拷贝，否则就是浅拷贝。  
深拷贝：  
该对象和原对象占用不同的内存空间，既拷贝存储在栈空间中的内容，又拷贝存储在堆空间中的内容  


*15. 上面的栈空间和堆空间怎么理解？*  



---
# 六. 语言特性相关  

*1.左值和右值的区别？左值引用和右值引用的区别，如何将左值转换成右值？*

*2.什么是野指针和悬空指针？*  

*3.指针和引用的区别？（5星）*  

*4.常量指针和指针常量的区别？（5星）*

*5.函数指针和指针函数的区别？（5星）*

*6.强制类型转换有哪几种？*  

---
# 七. 设计模式

*1.了解哪些设计模式*

*2.什么是单例模式？如何实现？应用场景？（5星）*
